##  Linux 基础命令
> 2019.2.28开始整理之前用过或忘掉的linux基础命令和linux基础知识, 每天整理三个， 加入新的有意思的命令

---
[TOC]


**2019.3.3**
> 今天整理查看系统信息命令
### 系统信息
#### uptime uname 
> uptime 系统运行时长， 平均负载， 当前登录用户数量
> uname 打印当前系统的信息
1. uptime  平均负载， 运行时长
```
uptime -p 友好的格式输出运行时间
uptime  最后三项分别是1/5/15分钟系统cpu平均负载
```
2. uname   获得电脑系统相关信息
- -a 全部信息
```
uname -a 
uname -m 电脑类型
uname -n 主机名称
uname --help  帮助选项
```
#### w  who  last
> w 获得当前登录用户和正在执行的进程， 第一行输出的uptime, 不太清楚有啥用处。
> who 显示当前登录系统的用户信息
> last 最近用户的最近登录信息， 可以读取数据文件, 数据文件cat不能读取，file 文件名   输出data
1. who
```
who -H   打印对应列的标题。。。
who -q   显示当前登录系统的人数和名称
whoami  打印当前登录的用户名
```
2. last 
> last作用是显示近期用户或终端的登录情况。通过last命令查看该程序的log，管理员可以获知谁曾经或者企图连接系统。执行last命令时，它会读取/var/log目录下名称为wtmp的文件，并把该文件记录的登录系统或终端的用户名单全部显示出来。[来源](https://www.cnblogs.com/diantong/p/8940154.html)
```
last -R 不显示登录系统或终端的主机名或ip
第三列是登录的ip或者内核。如果你看见：0.0 或者什么都没有，这意味着用户用过本地终端链接。除了重启活动，内核版本会显示再状态中；

last -d 将ip转换成主机名

last -F 显示登录的完整时间
```
#### date cal
> date 显示或者设置系统时间
> cal 显示日历， 用处不多， 每咋用过， 直到就行
1. date
```
date -d "1 day" 输出一天后的时间
data -d "1 day ago" 一天前的   "可以指定日期显示"
date +"%Y_%m_%d %H:%M%S"   %Y是年， %m是月， %d天，指定格式显示
date -s "20190303" 设置日期和时间
```



**2019.3.2**
> 今天整理bash通配符(? * )， 任务管理和，转义字符等
### 命令系统
####  通配符 ? *  [list]
> ?代表匹配单个任意字符                   
> *代表匹配任意多个字符
> [list] 匹配在list集合中任意字符
> [ ! list] 和上面 相反                                 
>[x1 - x2] 匹配x1到x2之间任意单一字符                
>[string1,  string2] 匹配集合中任一字符串
> 通配符配合linux命令使用， 效果很棒

#### 任务管理 基本字符含义
1. &
```
在命令后加上& 代表后台执行。可用fg唤醒
command &
```
2. ; (分号)
```
以分号分隔的命令， 顺序执行
command1 ; command2    #先执行command1 后执行command2， 返回值为最后一个运行结果(command2)
```
3. &&
```
命令以&&链接， 只有当第一个命令执行成功才执行第二条命令
command1 && command2      #command1执行成功才执行command2， 否则不执行command2
```
4.  || 
```
命令以||链接， 第一个命令执行成功, 不执行第二条命令， 否则执行
command1 || command2      #command1执行失败才执行command2， 否则不执行command2
```
5.    ``
```
用``把命令括起来， 代表执行时系统优先执行``中的命令， 然后带入父命令中继续运行， 适用与命令中包含另一个命令
command1 `command2`     #把command2的执行输出， 返回给command1的输入
```
6.  ctrl + z
```
组合键
在shell中执行命令时， 按下组合键代表挂起该命令
```
7. bg, fg
```
将一个在挂起的命令，变成继续执行

通过bg %num 即可将挂起的job的状态由stopped改为running，仍在后台执行；当需要改为在前台执行时，执行命令fg %num即可；
```

9. jobs
```
在linux下执行jobs, 可以看到该shell下的后台执行的和挂起的任务以及编号
```
#### 转义字符  "" '' \  重定向> >> 
>在这也总结下重定向的概念    >  >> 都是重定向，  >> 作用和> 基本相同， 但是>>是往文件里追加， 而> 会覆盖  ，都是作为标准输入， 可以当作可执行文件的输入,  如：  ./a.out  <  file1 
> 需要注意的是， 这里 > 不要在想写回源文件时乱用， 举例    cat a.c | tr "x" "n" | > a.c， 这里就会发现a,c被你搞没了， 因为他会先以覆盖形式打开a.c后执行前面命令， 想写回可以用tee, 就是把> 替换成tee，不做介绍

1. "" 软转义
```
软转义， 其内部只允许出现特定的shell 元字符($, \, `) $用于变量替换， \用于转义单个字符
`用于命令替换
```
2. '' 硬转义              
```
硬转义， 硬引用， 其内部关闭所有shell元字符，通配符，内部不允许出现单引号''
```
3. \ 转义后面的单个字符 
```
去掉后面紧跟着的元字符或通配符的特殊含义
```

### 常用命令
**2019.2.28**
#### grep  文本检索
> 一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。

-  grep -i "moying" a.txt      忽略大小写查找含有字符串"moying"
-  grep -w  "moying" a.txt    完全匹配
-  -v    反转匹配
-   -e  -E   多模式串检索  -e    要分开    -E 以管道符分割 grep -E "moying | yingmo" a.txt    
-  -c  输出匹配的行数
-  -o 只输出检索到的词， 而不是一行
-  可以加入正则来检索
	
#### tr 字符转换
> tr -[cdst] [第一字符集] [第二字符集]   
>  tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。

- -d 删除第一字符集的字符
- -c  反转替换， 取第一字符集的补集， 来被第二字符集提替换
- -s 连续压缩重复的字符为单个字符， cat a.txt  | tr -s "\n"  删除空行
- -t  默认用第一字符集的长度来替换， -t 消减第一字符集的长度，用第二字符集的长度。
- tr [a-z] [A-Z]   小写转换大写

#### find 文件查找
> 强大的文件搜索命令, 注意查找根目录时最好加上管理员权限， 不然就会  哇  哇  哇
> find path -option     最近知道一个-exec  command {} \;  和  -delete 可以直接删除   -perm  664 权限

- 查找本目录下所有的c程序
```
find . -name "*.c"
```
- 查找本目录下所有文件夹  
```
find . -type d 

-exec  command  {}  \;  对每个检索到的目标执行command 命令
find . -type d -exec ls {} \;   展开所有文件夹中的内容

-print  输出匹配到的目标
find . -type d -print  -exec ls {} \;   展开所有文件夹中文件

-ok   交互式匹配， 没检索到匹配项需要确认
find . -type d -ok ls {} \;   展开所有文件夹中文件
```

- 查找文件以时间来查找
```
find ./ -mtime -2  查找文件更新日时在距现在时刻二天以内的文件
find ./ -mtime +2  查找文件更新日时在距现在时刻二天以上的文件
find ./ -mtime 2   查找文件更新日时在距现在时刻一天以上二天以内的文件
find ./ -newer abc  查找文件更新时间比文件abc的内容更新时间新的文件


```
- 查找文件以大小来查找   
```
find ./ -size -10m 查找10M以内的文件或目录
find ./ -empty 查找空文件或空目录
find ./ -empty -type f -delete   查找空文件并删除
```
---
**2019.3.1**
> 今天测试命令时， 想快速建立一个指定大小的文件， 才发现不会适合的命令

#### dd 磁盘管理(备份) 
> 用于读取、转换并输出数据。dd可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。 命令很强大 
> 
> if=文件名：输入文件名，缺省为标准输入。即指定源文件。
> of=文件名：输出文件名，缺省为标准输出。即指定目的文件。 
> bs=块大小，  count=块数量，   //最终文件大小= bs * count
> 有意思的选项 conv=很多参数， 例如： ucase 转大写， lcase转小写 

- 创建指定大小的文件，用0填充
```
sudo dd if=/dev/zero of=./a.txt bs=500k count=6  //创建一个6×500K的文件， /dev/zero提供无数的0。 此处应该是二进制的0， 因为cat a.txt 是空， 可以用od 命令去查看 od a.txt，这里不介绍 
```
- 备份文件， 不能是文件夹
```
sudo dd if=/linux/1_happy.txt of=./1_happy_back.txt   //这里只复制文件内容，不复制文件权限
```

- 销毁磁盘数据
```
dd if=/dev/urandom of=/dev/hda1   // 利用随机的数据填充磁盘，必要的场合可以用来销毁数据。
```
- [更多秀秀的操作](https://www.cnblogs.com/jikexianfeng/p/6103500.html)

#### cat  tac 查看文件内容
> cat 为正向按行读取， tac 为反向按行读取

- 查看文件内容
```
cat a.txt //查看文件
cat -n a.txt //从1开始按行编号
cat -b a.txt  //对空白行不编号
cat -s a.txt  //对多个连续空行， 压缩成一个空行
tac 没有上述选项。。 有什么好的玩法没玩过
```
- 从标准输入写入指定文件
```
cat << END  >> a.txt     从标准输入追加到a.txt    输入END结束， 可替换成别的结束字符
cat << END > a.txt       从标准输入覆盖到a.txt
一个很好的解释
1、cat << EOF，以EOF输入字符为标准输入结束：
2、cat>filename，创建文件，并把标准输入输出到filename文件中，以ctrl+d作为输入结束：
注意：输入时是没有'>'的。
3、cat>filename<<EOF，以EOF作为输入结束，和ctrl+d的作用一样：
```
#### cut 文本切割
> 从文本中提取分割有效的信息， 很好用， 但是因为有时分割符不好确定，可以使用awk
- -d 指定分隔的字符， 默认是TAB        
- -f 指定显示范围
- -b 按照字节选取
- -c 按照字符选取    反正在我电脑上-b  和 -c是一样的， 我的是中文算3个字节编码
```
cat /etc/passwd | cut -b1-3　#取每行的第1-3字字节

cat /etc/passwd | cut -b1-3,5-7,8　#取每行的第1-3,5-7,8的字节(后面的数字会先进行从小到大的排列) 需要事先知道具体字节，很容易出错

cat song.txt |cut -nb 1,2,3  #当 -b 添加 -n 后则不会分割多字节 (我的系统是utf-8，所以需要用三个字节来表示一个汉字)
cat /etc/passwd | cut -c1,3 #适用于中文 

cat /etc/passwd | cut -d : -f 3 #以:分割，取第三段

```
---




[gdb](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html)




